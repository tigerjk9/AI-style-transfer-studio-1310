<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 그림체 변신 스튜디오</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css');
        @import url('https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@400;700&display=swap');
        
        body { 
            font-family: 'Pretendard', sans-serif;
            background-color: #2c2a29;
        }
        .font-myeongjo { font-family: 'Nanum Myeongjo', serif; }

        .hidden-file-input {
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            position: absolute;
            z-index: -1;
        }

        .modal {
            display: none;
            opacity: 0;
            transition: opacity 300ms ease-in-out;
        }
        .modal.show {
            display: flex;
            opacity: 1;
        }

        /* Custom Slider Styles */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            background: #4a5568; /* gray-700 */
            height: 0.5rem;
            border-radius: 0.5rem;
        }
        input[type=range]::-moz-range-track {
            background: #4a5568;
            height: 0.5rem;
            border-radius: 0.5rem;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -4px;
            height: 1.25rem;
            width: 1.25rem;
            background-color: #e3d9c6;
            border-radius: 9999px;
            border: 2px solid #2c2a29;
        }
        input[type=range]::-moz-range-thumb {
            height: 1.25rem;
            width: 1.25rem;
            background-color: #e3d9c6;
            border-radius: 9999px;
            border: 2px solid #2c2a29;
        }
    </style>
</head>
<body class="bg-[#2c2a29] min-h-screen text-[#e3d9c6] p-4 sm:p-8 flex flex-col items-center">

    <div class="w-full max-w-5xl mx-auto">
        <header class="text-center my-8">
             <h1 class="text-5xl sm:text-6xl font-myeongjo font-bold">AI 그림체 변신 스튜디오</h1>
             <p class="text-gray-400 mt-4 text-lg">내 사진이 멋진 캐릭터로 변신!</p>
        </header>
 
        <main id="main-content" class="w-full">
            <!-- Initial Upload and API Key Section -->
            <div id="upload-section">
                <div class="w-full p-8 sm:p-12 bg-black/20 border border-gray-700 rounded-lg text-center backdrop-blur-sm">
                    <div id="image-placeholder">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-gray-400 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1"><path stroke-linecap="round" stroke-linejoin="round" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"></path><path stroke-linecap="round" stroke-linejoin="round" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                        <h2 class="text-xl font-semibold mt-4 text-gray-300">캐릭터로 만들 얼굴 사진을 올려주세요</h2>
                        <p class="text-gray-500 mt-2">얼굴이 잘 보이는 선명한 사진일수록 결과가 좋아요.</p>
                    </div>
                    <div id="image-preview-container" class="hidden">
                        <img id="image-preview" src="" alt="업로드된 원본" class="max-w-full max-h-80 mx-auto rounded-md object-contain">
                    </div>

                    <label for="image-upload" id="upload-label" class="mt-6 inline-block bg-[#e3d9c6] text-[#2c2a29] font-semibold py-2 px-6 rounded-md shadow-md hover:bg-white/80 transition-colors cursor-pointer">
                        사진 선택하기
                    </label>
                    <input id="image-upload" type="file" accept="image/*" class="hidden-file-input">
                </div>
 
                <div class="w-full max-w-2xl mx-auto mt-8">
                    <label for="api-key" class="block text-md font-semibold text-gray-400">Google Gemini API Key</label>
                    <input type="password" id="api-key" class="mt-2 block w-full px-3 py-2 bg-black/20 border border-gray-700 rounded-md shadow-sm placeholder-gray-500 focus:outline-none focus:ring-[#e3d9c6] focus:border-[#e3d9c6] sm:text-sm" placeholder="AI-로 시작하는 API 키를 여기에 입력하세요">
                    <p class="mt-2 text-sm text-gray-500 text-right">
                    API 키가 없으신가요? <a href="https://aistudio.google.com/apikey" target="_blank" rel="noopener noreferrer" class="font-medium text-[#e3d9c6] hover:underline">여기서 발급받으세요.</a>
                    </p>
                </div>
                
                <div id="options-section" class="w-full max-w-2xl mx-auto mt-8 hidden">
                    <div class="bg-black/20 border border-gray-700 rounded-lg p-6">
                        <h3 class="text-lg font-semibold text-gray-300 mb-4">1. 변신할 그림체 선택 (여러 개 선택 가능)</h3>
                        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-x-4 gap-y-3 mb-6" id="style-checkboxes">
                            <!-- Checkboxes will be dynamically inserted here -->
                        </div>
                
                        <h3 class="text-lg font-semibold text-gray-300 mb-4">2. 그림체별 생성 개수 조절</h3>
                        <div class="flex items-center gap-4">
                            <input type="range" id="generation-count-slider" min="1" max="3" value="1" class="w-full">
                            <span id="generation-count-value" class="font-bold text-lg text-[#e3d9c6] w-8 text-center bg-black/20 py-1 rounded-md">1</span>
                        </div>
                    </div>
                     <p class="text-xs text-gray-500 text-center mt-4 px-2">
                        <strong>참고:</strong> AI가 사용자의 얼굴 특징을 항상 완벽하게 반영하지는 못할 수 있어요. 최상의 결과를 위해 여러 번 시도해 보세요!
                    </p>
                    <div id="generate-button-container" class="text-center mt-6">
                        <button id="generate-button" class="bg-[#8a6e50] text-white font-bold py-3 px-12 rounded-lg shadow-lg hover:bg-[#a18666] transition-all duration-300 ease-in-out transform hover:scale-105 disabled:bg-gray-700 disabled:text-gray-500 disabled:shadow-none disabled:transform-none disabled:cursor-not-allowed flex items-center justify-center text-lg mx-auto">
                            그림체 변신 시작!
                        </button>
                    </div>
                </div>

            </div>
            
            <!-- Error and Loading Section -->
            <div id="error-message" class="hidden text-center my-4 p-3 bg-red-900/50 text-red-300 rounded-lg max-w-2xl mx-auto"></div>
            <div id="spinner" class="hidden w-full flex justify-center items-center mt-12">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="animate-spin text-[#e3d9c6]">
                    <path d="M21 6v.397a5 5 0 0 1-2.418 4.349l-2.01 1.256a5 5 0 0 0-2.572 4.342V21"></path><path d="M3 18v-.397a5 5 0 0 1 2.418-4.349l-2.01-1.256a5 5 0 0 0 2.572-4.342V3"></path><path d="M3 6h18"></path><path d="M3 18h18"></path>
                </svg>
            </div>
 
            <!-- Results Section -->
            <div id="results-section" class="hidden">
                <div class="text-center border-b border-gray-700 pb-8 mb-10">
                    <h2 class="text-4xl font-myeongjo font-bold">AI 변신 결과</h2>
                    <p class="text-gray-400 mt-2">AI가 그린 나의 새로운 캐릭터!</p>
                    <div class="flex justify-center items-center gap-4 mt-6">
                        <button id="download-all-button" class="bg-green-600/80 text-white font-semibold py-2 px-5 rounded-md shadow-md hover:bg-green-500 transition-colors">모두 저장하기</button>
                        <button id="reset-button" class="bg-gray-700/80 text-white font-semibold py-2 px-5 rounded-md shadow-md hover:bg-gray-600 transition-colors">새로 시작하기</button>
                    </div>
                </div>
                <div id="results-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
                    <!-- Generated images will be injected here -->
                </div>
            </div>
        </main>

        <footer class="text-center text-gray-400 text-sm mt-16 pb-8">
            <p>Made by 김진관 (닷커넥터)</p>
            <p class="mt-1">배움, 나눔, 성장을 추구하는 연결주의자</p>
        </footer>
    </div>
 
    <!-- Image Modal -->
    <div id="image-modal" class="modal fixed inset-0 bg-black/80 items-center justify-center z-50">
        <div class="relative bg-black/50 p-2 sm:p-4 rounded-lg shadow-2xl max-w-[90vw] max-h-[90vh]">
            <img id="modal-image" src="" alt="확대된 이미지" class="max-w-full max-h-[85vh] object-contain rounded-md">
            <button id="modal-close-button" class="absolute -top-4 -right-4 sm:top-2 sm:right-2 text-white bg-black/60 rounded-full p-1 hover:bg-white/20 transition-colors" aria-label="Close">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    
<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- STATE MANAGEMENT ---
    let originalImage = null; // { file, base64 }
    let generatedImages = [];
    let isGenerating = false;
    let apiKey = '';
    let generationCount = 1;

    // --- DOM ELEMENTS ---
    const imageUploadInput = document.getElementById('image-upload');
    const uploadLabel = document.getElementById('upload-label');
    const imagePlaceholder = document.getElementById('image-placeholder');
    const imagePreviewContainer = document.getElementById('image-preview-container');
    const imagePreview = document.getElementById('image-preview');
    const apiKeyInput = document.getElementById('api-key');
    const generateButton = document.getElementById('generate-button');
    const errorMessageDiv = document.getElementById('error-message');
    const spinner = document.getElementById('spinner');
    const uploadSection = document.getElementById('upload-section');
    const resultsSection = document.getElementById('results-section');
    const resultsGrid = document.getElementById('results-grid');
    const downloadAllButton = document.getElementById('download-all-button');
    const resetButton = document.getElementById('reset-button');
    const imageModal = document.getElementById('image-modal');
    const modalImage = document.getElementById('modal-image');
    const modalCloseButton = document.getElementById('modal-close-button');
    const optionsSection = document.getElementById('options-section');
    const styleCheckboxesContainer = document.getElementById('style-checkboxes');
    const generationCountSlider = document.getElementById('generation-count-slider');
    const generationCountValue = document.getElementById('generation-count-value');

    // --- CONSTANTS ---
    const PHOTO_STYLES = [
        { name: "지브리 스타일", prompt: "Transform the person in the photo into a character from a Studio Ghibli film. Maintain their key facial features, hair style, and expression. The style should be painterly, with soft lighting and a nostalgic, hand-drawn feel. The background should be a simple, soft-focus natural scene like a gentle sky or green field. **Final Output Specification: Generate a high-resolution horizontal image with a strict 13:10 aspect ratio, suitable for printing.**" },
        { name: "짱구는 못말려 스타일", prompt: "**MANDATORY INSTRUCTION: Your primary goal is to adapt the person in the provided photo into a new character.** This new character MUST be drawn in the art style of the anime 'Crayon Shin-chan' (짱구는 못말려). **ABSOLUTELY DO NOT draw the existing, famous character Shin-chan Nohara.** You must create a unique character that resembles the person in the photo. The art style is defined by very simple, thick, and bold outlines, minimally detailed faces, circular/oval-shaped heads, and simple, flat coloring. Preserve the hair style and key facial structure of the person in the photo, but translate them into this simplified animation style. **Final Output Specification: Generate a high-resolution horizontal image with a strict 13:10 aspect ratio, suitable for printing.**" },
        { name: "마블 코믹스 스타일", prompt: "Reimagine the person in the photo as a character drawn in a modern Marvel comic book style. The art should be dynamic and heroic, with strong, clean line art and dramatic, high-contrast cel shading. Capture their likeness but give them a powerful and determined expression. The background should be a simple, explosive graphic effect or a solid color. **Final Output Specification: Generate a high-resolution horizontal image with a strict 13:10 aspect ratio, suitable for printing.**" },
        { name: "디즈니/픽사 스타일", prompt: "Illustrate the person in the photo as a 3D character from a modern Disney or Pixar animated movie. Give them large, expressive eyes, smooth and clean digitally rendered skin and hair, and soft, dimensional lighting. Retain their likeness and friendly expression. The background should be a simple, soft, magical blue or purple gradient. **Final Output Specification: Generate a high-resolution horizontal image with a strict 13:10 aspect ratio, suitable for printing.**" },
        { name: "80년대 레트로 애니", prompt: "Redraw the person in the picture in the style of an 80s Japanese retro anime. The style should include slightly faded, nostalgic colors, distinctive sharp-lined hair with highlights, and large, detailed eyes with a vintage feel. Keep the original person's facial features recognizable. Render from the chest up against a simple geometric or gradient background. **Final Output Specification: Generate a high-resolution horizontal image with a strict 13:10 aspect ratio, suitable for printing.**" },
        { name: "웹툰 주인공 스타일", prompt: "Turn the person in the photo into a Korean webtoon main character. The style should be clean and polished, with crisp digital lines and cell shading. Emphasize their hair with a stylish, slightly idealized look and make their eyes expressive. Ensure the character is still recognizable as the person in the photo. The background should be a simple speed-line or soft-focus cityscape effect. **Final Output Specification: Generate a high-resolution horizontal image with a strict 13:10 aspect ratio, suitable for printing.**" }
    ];

    // --- INITIALIZATION ---
    PHOTO_STYLES.forEach((style, index) => {
        const div = document.createElement('div');
        div.className = 'flex items-center';
        div.innerHTML = `
            <input id="style-${index}" type="checkbox" value="${index}" checked class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-[#8a6e50] focus:ring-[#a18666] focus:ring-offset-gray-800">
            <label for="style-${index}" class="ml-3 block text-sm font-medium text-gray-300">${style.name}</label>
        `;
        styleCheckboxesContainer.appendChild(div);
    });
    const styleCheckboxes = styleCheckboxesContainer.querySelectorAll('input[type="checkbox"]');


    // --- UI UPDATE FUNCTIONS ---
    const showError = (message) => {
        errorMessageDiv.textContent = message;
        errorMessageDiv.classList.remove('hidden');
    };
    const clearError = () => {
        errorMessageDiv.textContent = '';
        errorMessageDiv.classList.add('hidden');
    };
    const updateGenerateButtonState = () => {
        const selectedStyles = Array.from(styleCheckboxes).filter(cb => cb.checked);
        generateButton.disabled = isGenerating || !apiKey || !originalImage || selectedStyles.length === 0;
    };
    const renderResultsGrid = () => {
        resultsGrid.innerHTML = '';
        generatedImages.forEach((image, index) => {
            const card = document.createElement('div');
            card.className = "bg-black/20 rounded-md shadow-lg transition-all duration-300 ease-in-out hover:shadow-2xl hover:shadow-black/50 hover:-translate-y-2 group border border-gray-800 flex flex-col";
            
            const imageContainerContent = 
                image.status === 'completed' ? `<img src="${image.src}" alt="${image.name}" class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-105">` :
                image.status === 'failed' ? `<div class="text-red-400 p-4 text-center">생성 실패</div>` :
                `<div class="w-full h-full flex items-center justify-center"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin text-gray-500"><path d="M21 12a9 9 0 1 1-6.219-8.56"></path></svg></div>`;

            card.innerHTML = `
                <div class="w-full bg-black rounded-t-md flex items-center justify-center overflow-hidden ${image.status === 'completed' ? 'cursor-pointer' : ''}" data-index="${index}" style="aspect-ratio: 13/10;">
                    ${imageContainerContent}
                </div>
                <div class="p-3 flex-grow flex flex-col justify-between">
                    <h3 class="font-semibold text-center text-md text-gray-300 mb-3">${image.name}</h3>
                    <button 
                        data-index="${index}"
                        class="w-full bg-gray-700/80 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:bg-gray-600 transition-colors disabled:bg-gray-800 disabled:text-gray-500 disabled:cursor-not-allowed flex items-center justify-center gap-2 download-button"
                        ${image.status !== 'completed' ? 'disabled' : ''}
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4 4m0 0l-4-4m4 4V4"></path></svg>
                        <span>저장하기</span>
                    </button>
                </div>
            `;
            resultsGrid.appendChild(card);
        });
    };

    // --- CORE LOGIC FUNCTIONS ---
    const handleImageChange = (e) => {
        const file = e.target.files[0];
        if (file) {
            clearError();
            const reader = new FileReader();
            reader.onloadend = () => {
                originalImage = { file: file, base64: reader.result };
                imagePreview.src = originalImage.base64;
                imagePlaceholder.classList.add('hidden');
                imagePreviewContainer.classList.remove('hidden');
                uploadLabel.textContent = '다른 사진 선택';
                optionsSection.classList.remove('hidden');
                updateGenerateButtonState();
            };
            reader.readAsDataURL(file);
        }
    };

    const getBase64Data = (dataUrl) => dataUrl.split(',')[1];

    const generateImageAPI = async (userApiKey, prompt, base64ImageData, mimeType, retries = 3, delay = 1000) => {
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${userApiKey}`;
        const payload = {
            contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: mimeType, data: base64ImageData } }] }],
            generationConfig: { responseModalities: ['IMAGE'] },
            safetySettings: [
                {
                    "category": "HARM_CATEGORY_HARASSMENT",
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_HATE_SPEECH",
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                    "threshold": "BLOCK_NONE"
                },
                {
                    "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                    "threshold": "BLOCK_NONE"
                }
            ]
        };
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                if (response.status === 429 && retries > 0) {
                    await new Promise(res => setTimeout(res, delay));
                    return generateImageAPI(userApiKey, prompt, base64ImageData, mimeType, retries - 1, delay * 2);
                }
                const errorData = await response.json();
                throw new Error(errorData.error?.message || `API 요청 실패: ${response.status}`);
            }
            const result = await response.json();
            const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
            if (!base64Data) {
                console.error("API Response did not contain image data. Full response:", JSON.stringify(result, null, 2));
                throw new Error("API 응답에서 이미지 데이터를 찾을 수 없습니다. 안전 필터에 의해 차단되었을 수 있습니다.");
            }
            return `data:image/png;base64,${base64Data}`;
        } catch (err) {
            console.error(`Error generating image for prompt "${prompt}":`, err);
            showError(`이미지 생성 오류: ${err.message}`);
            return null;
        }
    };

    const handleGenerateClick = async () => {
        const selectedStyleIndexes = Array.from(styleCheckboxes)
            .filter(cb => cb.checked)
            .map(cb => parseInt(cb.value, 10));

        if (!originalImage || !apiKey || selectedStyleIndexes.length === 0) {
            showError("사진을 선택하고, API 키를 입력하고, 하나 이상의 그림체를 선택해주세요.");
            return;
        }

        isGenerating = true;
        updateGenerateButtonState();
        clearError();
        uploadSection.classList.add('hidden');
        spinner.classList.remove('hidden');
        
        const tasks = [];
        selectedStyleIndexes.forEach(index => {
            const style = PHOTO_STYLES[index];
            for (let i = 0; i < generationCount; i++) {
                tasks.push({
                    name: generationCount > 1 ? `${style.name} ${i + 1}` : style.name,
                    prompt: style.prompt,
                });
            }
        });

        generatedImages = tasks.map(task => ({ name: task.name, status: 'loading', src: null }));
        renderResultsGrid();
        resultsSection.classList.remove('hidden');
        spinner.classList.add('hidden');

        const originalBase64Data = getBase64Data(originalImage.base64);
        const originalMimeType = originalImage.file.type;
        
        const generationPromises = tasks.map((task, index) =>
            generateImageAPI(apiKey, task.prompt, originalBase64Data, originalMimeType).then(src => {
                generatedImages[index] = { ...generatedImages[index], status: src ? 'completed' : 'failed', src: src };
                renderResultsGrid();
            })
        );

        await Promise.all(generationPromises);
        isGenerating = false;
        updateGenerateButtonState();
    };

    const handleDownload = (imageSrc, filename) => {
        if (!imageSrc) return;
        const link = document.createElement('a');
        link.href = imageSrc;
        link.download = `${filename.replace(/\s/g, '_')}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    const handleDownloadAll = async () => {
        if (typeof window.JSZip === 'undefined') {
            showError("다운로드 라이브러리를 불러오는 중입니다. 잠시 후 다시 시도해주세요.");
            return;
        }
        const zip = new window.JSZip();
        const imagePromises = generatedImages
            .filter(img => img.status === 'completed')
            .map(async (img) => {
                const response = await fetch(img.src);
                const blob = await response.blob();
                zip.file(`${img.name.replace(/\s/g, '_')}.png`, blob);
            });
        await Promise.all(imagePromises);
        zip.generateAsync({ type: "blob" }).then((content) => {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = "AI_캐릭터_사진.zip";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
    };

    const handleReset = () => {
        originalImage = null;
        generatedImages = [];
        isGenerating = false;
        
        imageUploadInput.value = '';
        imagePreview.src = '';
        imagePlaceholder.classList.remove('hidden');
        imagePreviewContainer.classList.add('hidden');
        uploadLabel.textContent = '사진 선택하기';
        
        resultsSection.classList.add('hidden');
        uploadSection.classList.remove('hidden');
        optionsSection.classList.add('hidden');
        
        styleCheckboxes.forEach(cb => cb.checked = true);
        generationCountSlider.value = 1;
        generationCountValue.textContent = '1';
        generationCount = 1;

        clearError();
        updateGenerateButtonState();
    };

    // --- EVENT LISTENERS ---
    imageUploadInput.addEventListener('change', handleImageChange);
    apiKeyInput.addEventListener('input', (e) => {
        apiKey = e.target.value;
        clearError();
        updateGenerateButtonState();
    });

    styleCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', updateGenerateButtonState);
    });

    generationCountSlider.addEventListener('input', (e) => {
        generationCount = parseInt(e.target.value, 10);
        generationCountValue.textContent = generationCount;
    });

    generateButton.addEventListener('click', handleGenerateClick);
    resetButton.addEventListener('click', handleReset);
    downloadAllButton.addEventListener('click', handleDownloadAll);

    resultsGrid.addEventListener('click', (e) => {
        const target = e.target;
        const downloadBtn = target.closest('.download-button');
        if (downloadBtn) {
            const index = downloadBtn.dataset.index;
            const image = generatedImages[index];
            if (image && image.status === 'completed') {
                handleDownload(image.src, image.name);
            }
            return;
        }

        const imageContainer = target.closest('[data-index]');
        if (imageContainer) {
             const index = imageContainer.dataset.index;
             const image = generatedImages[index];
             if (image && image.status === 'completed') {
                 modalImage.src = image.src;
                 imageModal.classList.add('show');
             }
        }
    });

    modalCloseButton.addEventListener('click', () => imageModal.classList.remove('show'));
    imageModal.addEventListener('click', (e) => {
        if (e.target === imageModal) {
            imageModal.classList.remove('show');
        }
    });
});
</script>

</body>
</html>

